#!/usr/bin/env ruby
# vim: set filetype=ruby:
$: << File.expand_path("../../lib/", __FILE__)

require 'adash'
require 'adash/config'
require 'adash/wait_indefinitely'
require 'optparse'
require 'fileutils'
require 'yaml'

opt = OptionParser.new

opt.on('-h', '--help') { puts 'help' }

def generate_serial(device_model)
  orig = [('a'..'z'), ('A'..'Z'), ('0'..'9')].map { |i| i.to_a }.flatten
  random_suffix = (0...16).map { orig[rand(orig.size)] }.join
  "#{device_model}_#{Time.now.to_i}_#{random_suffix}"
end

def get_data
  if File.exist?(Adash::Config.credentials_path)
    data = YAML.load_file(Adash::Config.credentials_path).to_h
  else
    data = { 'authorized_devices' => [] }
  end
  data
end

argv = opt.order(ARGV)
unless argv.empty?
  subcmd = argv.shift
  case subcmd
  when 'init'
    init_opt = OptionParser.new
    init_opt.on('-h', '--help') { puts 'init help' }
    is_test = false
    init_opt.on('-t', '--test') {
      is_test = true
      puts 'TEST MODE'
    }
    argv = init_opt.parse(argv)
    if argv.size < 1
      puts 'Usage: adash init device_model'
      exit 2
    end
    device_model = argv.shift
    serial = generate_serial(device_model)
    data = get_data
    hit = data['authorized_devices'].find_index { |d| d['device_model'] == device_model }
    if hit
      puts "Adash knows #{device_model} device."
      exit 3
    end
    wi = Adash::WaitIndefinitely.new(device_model, serial)
    Signal.trap(:INT){ wi.shutdown }
    code = wi.get_code
    FileUtils.mkdir_p(File.expand_path('..', Adash::Config.credentials_path))
    new_device = {
      'device_model' => device_model,
      'serial' => serial,
      'authorization_code' => code,
      'redirect_uri' => wi.redirect_uri
    }
    new_device['is_test'] = true if is_test
    data['authorized_devices'] << new_device
    open(Adash::Config.credentials_path, 'w') do |f|
      f.write(data.to_yaml)
    end
  when 'list'
    data = get_data
    data['authorized_devices'].each_index do |index|
      device = data['authorized_devices'][index]
      puts "---- #{index}"
      puts "* device_model: #{device['device_model']}"
      puts "  serial: #{device['serial']}"
      puts '  THIS DEVICE IS TEST PURCHASE MODE' if device['is_test']
    end
  when 'deregistrate'
    if argv.size < 1
      puts 'Usage: adash deregistrate device_model'
      exit 4
    end
    device_model = argv.shift
    client = Adash::Client.new(device_model)
    resp = client.deregistrate_device
  when 'list-slot'
    if argv.size < 1
      puts 'Usage: adash list-slot device_model'
      exit 5
    end
    device_model = argv.shift
    client = Adash::Client.new(device_model)
    resp = client.subscription_info
    index = 0
    resp.json['slotsSubscriptionStatus'].each do |slot_id, available|
      puts "---- #{index}"
      puts "* slot_id: #{slot_id}"
      puts "  available: #{available}"
      index =+ 1
    end
  when 'replenish'
    if argv.size < 2
      puts 'Usage: adash replenish device_model slot_id'
      exit 6
    end
    device_model = argv.shift
    slot_id = argv.shift
    client = Adash::Client.new(device_model)
    resp = client.replenish(slot_id)
  else
    $stderr.puts "no such subcommand: #{k}"
    exit 1
  end
end

